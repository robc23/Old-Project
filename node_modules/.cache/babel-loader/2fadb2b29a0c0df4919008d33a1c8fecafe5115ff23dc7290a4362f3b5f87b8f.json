{"ast":null,"code":"/**\n * @license Ticker\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport EventDispatcher from \"../events/EventDispatcher\";\nimport Event from \"../events/Event\";\n\n/**\n * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick\n * event to be notified when a set time interval has elapsed.\n *\n * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval\n * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and\n * can not be instantiated.\n *\n * @todo Pass timingMode, maxDelta, paused values as instantiation arguments?\n *\n * @memberof core\n * @example\n * Ticker.addEventListener(\"tick\", event => {\n *   // Actions carried out each tick (aka frame)\n *   if (!event.paused) {\n *     // Actions carried out when the Ticker is not paused.\n *   }\n * });\n * @example\n * // Ticker export explanation\n * import Ticker, { Ticker as TickerClass, getTicker } from \"@createjs/core\";\n * Ticker.name, Ticker.RAF // -> createjs.global, undefined\n * TickerClass.RAF // -> raf\n * Ticker === getTicker(\"createjs.global\") // -> true\n *\n * @extends core.EventDispatcher\n * @param {string} name The name assigned to this instance.\n */\nclass Ticker extends EventDispatcher {\n  /**\n   * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It\n   * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and\n   * dispatches the tick when the time is within a certain threshold.\n   *\n   * This mode has a higher variance for time between frames than {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}},\n   * but does not require that content be time based as with {{#crossLink \"Ticker/RAF:property\"}}{{/crossLink}} while\n   * gaining the benefits of that API (screen synch, background throttling).\n   *\n   * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so\n   * framerates of 10, 12, 15, 20, and 30 work well.\n   *\n   * Falls back to {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}} if the requestAnimationFrame API is not\n   * supported.\n   *\n   * @static\n   * @type {string}\n   * @default \"synched\"\n   * @readonly\n   */\n  static get RAF_SYNCHED() {\n    return \"synched\";\n  }\n\n  /**\n   * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.\n   * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.\n   * You can leverage {@link core.Ticker#getTime} and the {@link core.Ticker#event:tick}\n   * event object's \"delta\" properties to make this easier.\n   *\n   * Falls back on {@link core.Ticker.TIMEOUT} if the requestAnimationFrame API is not supported.\n   *\n   * @static\n   * @type {string}\n   * @default \"raf\"\n   * @readonly\n   */\n  static get RAF() {\n    return \"raf\";\n  }\n\n  /**\n   * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not\n   * provide the benefits of requestAnimationFrame (screen synch, background throttling).\n   *\n   * @static\n   * @type {string}\n   * @default \"timeout\"\n   * @readonly\n   */\n  static get TIMEOUT() {\n    return \"timeout\";\n  }\n  constructor(name) {\n    super();\n\n    /**\n     * The name of this instance.\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use.\n     *\n     * @see {@link core.Ticker.TIMEOUT}\n     * @see {@link core.Ticker.RAF}\n     * @see {@link core.Ticker.RAF_SYNCHED}\n     *\n     * @type {string}\n     * @default Ticker.TIMEOUT\n     */\n    this.timingMode = Ticker.TIMEOUT;\n\n    /**\n     * Specifies a maximum value for the delta property in the tick event object. This is useful when building time\n     * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,\n     * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value\n     * (ex. maxDelta=50 when running at 40fps).\n     *\n     * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta\n     * when using both delta and other values.\n     *\n     * If 0, there is no maximum.\n     *\n     * @type {number}\n     * @default 0\n     */\n    this.maxDelta = 0;\n\n    /**\n     * When the ticker is paused, all listeners will still receive a tick event, but the `paused` property\n     * of the event will be `true`. Also, while paused the `runTime` will not increase.\n     *\n     * @example\n     * Ticker.addEventListener(\"tick\", event => console.log(event.paused, Ticker.getTime(false), Ticker.getTime(true)));\n     * Ticker.paused = true;\n     *\n     * @see {@link core.Ticker#event:tick}\n     * @see {@link core.Ticker#getTime}\n     * @see {@link core.Ticker#getEventTime}\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.paused = false;\n\n    /**\n     * @private\n     * @type {boolean}\n     * @default false\n     */\n    this._inited = false;\n\n    /**\n     * @private\n     * @type {number}\n     * @default 0\n     */\n    this._startTime = 0;\n\n    /**\n     * @private\n     * @type {number}\n     * @default 0\n     */\n    this._pausedTime = 0;\n\n    /**\n     * The number of ticks that have passed.\n     *\n     * @private\n     * @type {number}\n     * @default 0\n     */\n    this._ticks = 0;\n\n    /**\n     * The number of ticks that have passed while Ticker has been paused.\n     *\n     * @private\n     * @type {number}\n     * @default\n     */\n    this._pausedTicks = 0;\n\n    /**\n     * @private\n     * @type {number}\n     * @default\n     */\n    this._interval = 50;\n\n    /**\n     * @private\n     * @type {number}\n     * @default\n     */\n    this._lastTime = 0;\n\n    /**\n     * @private\n     * @type {Array}\n     * @default null\n     */\n    this._times = null;\n\n    /**\n     * @private\n     * @type {Array}\n     * @default null\n     */\n    this._tickTimes = null;\n\n    /**\n     * Stores the timeout or requestAnimationFrame id.\n     *\n     * @private\n     * @type {number}\n     * @default null\n     */\n    this._timerId = null;\n\n    /**\n     * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode\n     * if that property changed and a tick hasn't fired.\n     *\n     * @private\n     * @type {boolean}\n     * @default true\n     */\n    this._raf = true;\n  }\n\n  /**\n   * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).\n   * Note that actual time between ticks may be more than specified depending on CPU load.\n   * This property is ignored if the ticker is using the `RAF` timing mode.\n   *\n   * @type {number}\n   */\n  get interval() {\n    return this._interval;\n  }\n  set interval(interval) {\n    this._interval = interval;\n    if (!this._inited) {\n      return;\n    }\n    this._setupTick();\n  }\n\n  /**\n   * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where\n   * `framerate == 1000/interval`.\n   *\n   * @type {number}\n   */\n  get framerate() {\n    return 1000 / this._interval;\n  }\n  set framerate(framerate) {\n    this.interval = 1000 / framerate;\n  }\n\n  /**\n   * Starts the tick. This is called automatically when the first listener is added.\n   */\n  init() {\n    if (this._inited) {\n      return;\n    }\n    this._inited = true;\n    this._times = [];\n    this._tickTimes = [];\n    this._startTime = this._getTime();\n    this._times.push(this._lastTime = 0);\n    this._setupTick();\n  }\n\n  /**\n   * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.\n   */\n  reset() {\n    if (this._raf) {\n      let f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;\n      f && f(this._timerId);\n    } else {\n      clearTimeout(this._timerId);\n    }\n    this.removeAllEventListeners(\"tick\");\n    this._timerId = this._times = this._tickTimes = null;\n    this._startTime = this._lastTime = this._ticks = 0;\n    this._inited = false;\n  }\n\n  /**\n   * Init the Ticker instance if it hasn't been already.\n   */\n  addEventListener(type, listener, useCapture) {\n    !this._inited && this.init();\n    return super.addEventListener(type, listener, useCapture);\n  }\n\n  /**\n   * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS\n   * because it only measures the time spent within the tick execution stack.\n   *\n   * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between\n   * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that\n   * there may be up to 35ms of \"idle\" time between the end of one tick and the start of the next.\n   *\n   * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of\n   * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something\n   * other than the tick is using ~80ms (another script, DOM rendering, etc).\n   *\n   * @param {number} [ticks=null] The number of previous ticks over which to measure the average time spent in a tick.\n   * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.\n   * @return {number} The average time spent in a tick in milliseconds.\n   */\n  getMeasuredTickTime() {\n    let ticks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const times = this._tickTimes;\n    if (!times || times.length < 1) {\n      return -1;\n    }\n    // by default, calculate average for the past ~1 second:\n    ticks = Math.min(times.length, ticks || this.framerate | 0);\n    return times.reduce((a, b) => a + b, 0) / ticks;\n  }\n\n  /**\n   * Returns the actual frames / ticks per second.\n   *\n   * @param {number} [ticks=null] The number of previous ticks over which to measure the actual frames / ticks per second.\n   * Defaults to the number of ticks per second.\n   * @return {number} The actual frames / ticks per second. Depending on performance, this may differ\n   * from the target frames per second.\n   */\n  getMeasuredFPS() {\n    let ticks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const times = this._times;\n    if (!times || times.length < 2) {\n      return -1;\n    }\n    // by default, calculate fps for the past ~1 second:\n    ticks = Math.min(times.length - 1, ticks || this.framerate | 0);\n    return 1000 / ((times[0] - times[ticks]) / ticks);\n  }\n\n  /**\n   * Returns the number of milliseconds that have elapsed since Ticker was initialized via {@link core.Ticker#init}.\n   * Returns -1 if Ticker has not been initialized. For example, you could use\n   * this in a time synchronized animation to determine the exact amount of time that has elapsed.\n   *\n   * @param {boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.\n   * If false, the value returned will be total time elapsed since the first tick event listener was added.\n   * @return {number} Number of milliseconds that have elapsed since Ticker was initialized or -1.\n   */\n  getTime() {\n    let runTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this._startTime ? this._getTime() - (runTime ? this._pausedTime : 0) : -1;\n  }\n\n  /**\n   * Similar to {@link core.Ticker#getTime}, but returns the time on the most recent {@link core.Ticker#event:tick}\n   * event object.\n   *\n   * @param {boolean} [runTime=false] If true, the runTime property will be returned instead of time.\n   * @returns {number} The time or runTime property from the most recent tick event or -1.\n   */\n  getEventTime() {\n    let runTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this._startTime ? (this._lastTime || this._startTime) - (runTime ? this._pausedTime : 0) : -1;\n  }\n\n  /**\n   * Returns the number of ticks that have been broadcast by Ticker.\n   *\n   * @param {boolean} [pauseable=false] Indicates whether to include ticks that would have been broadcast\n   * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.\n   * If false, tick events that would have been broadcast while Ticker was paused will be included in the return\n   * value.\n   * @return {number} of ticks that have been broadcast.\n   */\n  getTicks() {\n    let pauseable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this._ticks - (pauseable ? this._pausedTicks : 0);\n  }\n\n  /**\n   * @private\n   */\n  _handleSynch() {\n    this._timerId = null;\n    this._setupTick();\n\n    // run if enough time has elapsed, with a little bit of flexibility to be early:\n    if (this._getTime() - this._lastTime >= (this._interval - 1) * 0.97) {\n      this._tick();\n    }\n  }\n\n  /**\n   * @private\n   */\n  _handleRAF() {\n    this._timerId = null;\n    this._setupTick();\n    this._tick();\n  }\n\n  /**\n   * @private\n   */\n  _handleTimeout() {\n    this._timerId = null;\n    this._setupTick();\n    this._tick();\n  }\n\n  /**\n   * @private\n   */\n  _setupTick() {\n    if (this._timerId != null) {\n      return;\n    } // avoid duplicates\n    const mode = this.timingMode || this._raf && Ticker.RAF;\n    if (mode === Ticker.RAF_SYNCHED || mode === Ticker.RAF) {\n      const f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;\n      if (f) {\n        this._timerId = f(mode === Ticker.RAF ? this._handleRAF.bind(this) : this._handleSynch.bind(this));\n        this._raf = true;\n        return;\n      }\n    }\n    this._raf = false;\n    this._timerId = setTimeout(this._handleTimeout.bind(this), this._interval);\n  }\n\n  /**\n   * @private\n   * @emits core.Ticker#event:tick\n   */\n  _tick() {\n    const paused = this.paused,\n      time = this._getTime(),\n      elapsedTime = time - this._lastTime;\n    this._lastTime = time;\n    this._ticks++;\n    if (paused) {\n      this._pausedTicks++;\n      this._pausedTime += elapsedTime;\n    }\n    if (this.hasEventListener(\"tick\")) {\n      const event = new Event(\"tick\");\n      const maxDelta = this.maxDelta;\n      event.delta = maxDelta && elapsedTime > maxDelta ? maxDelta : elapsedTime;\n      event.paused = paused;\n      event.time = time;\n      event.runTime = time - this._pausedTime;\n      this.dispatchEvent(event);\n    }\n    this._tickTimes.unshift(this._getTime() - time);\n    while (this._tickTimes.length > 100) {\n      this._tickTimes.pop();\n    }\n    this._times.unshift(time);\n    while (this._times.length > 100) {\n      this._times.pop();\n    }\n  }\n\n  /**\n   * @private\n   */\n  _getTime() {\n    const now = window.performance && window.performance.now;\n    return (now && now.call(performance) || new Date().getTime()) - this._startTime;\n  }\n  static on(type, listener, scope, once, data, useCapture) {\n    return _instance.on(type, listener, scope, once, data, useCapture);\n  }\n  static removeEventListener(type, listener, useCapture) {\n    _instance.removeEventListener(type, listener, useCapture);\n  }\n  static off(type, listener, useCapture) {\n    _instance.off(type, listener, useCapture);\n  }\n  static removeAllEventListeners(type) {\n    _instance.removeAllEventListeners(type);\n  }\n  static dispatchEvent(eventObj, bubbles, cancelable) {\n    return _instance.dispatchEvent(eventObj, bubbles, cancelable);\n  }\n  static hasEventListener(type) {\n    return _instance.hasEventListener(type);\n  }\n  static willTrigger(type) {\n    return _instance.willTrigger(type);\n  }\n  static toString() {\n    return _instance.toString();\n  }\n  static init() {\n    _instance.init();\n  }\n  static reset() {\n    _instance.reset();\n  }\n  static addEventListener(type, listener, useCapture) {\n    _instance.addEventListener(type, listener, useCapture);\n  }\n  static getMeasuredTickTime(ticks) {\n    return _instance.getMeasuredTickTime(ticks);\n  }\n  static getMeasuredFPS(ticks) {\n    return _instance.getMeasuredFPS(ticks);\n  }\n  static getTime(runTime) {\n    return _instance.getTime(runTime);\n  }\n  static getEventTime(runTime) {\n    return _instance.getEventTime(runTime);\n  }\n  static getTicks(pauseable) {\n    return _instance.getTicks(pauseable);\n  }\n  static get interval() {\n    return _instance.interval;\n  }\n  static set interval(interval) {\n    _instance.interval = interval;\n  }\n  static get framerate() {\n    return _instance.framerate;\n  }\n  static set framerate(framerate) {\n    _instance.framerate = framerate;\n  }\n  static get name() {\n    return _instance.name;\n  }\n  static set name(name) {\n    _instance.name = name;\n  }\n  static get timingMode() {\n    return _instance.timingMode;\n  }\n  static set timingMode(timingMode) {\n    _instance.timingMode = timingMode;\n  }\n  static get maxDelta() {\n    return _instance.maxDelta;\n  }\n  static set maxDelta(maxDelta) {\n    _instance.maxDelta = maxDelta;\n  }\n  static get paused() {\n    return _instance.paused;\n  }\n  static set paused(paused) {\n    _instance.paused = paused;\n  }\n}\n\n/**\n * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused.\n *\n * @example\n * Ticker.addEventListener(\"tick\", event => console.log(\"Paused:\", event.paused, event.delta));\n *\n * @event core.Ticker#tick\n * @type {Object}\n * @property {Object} target The object that dispatched the event.\n * @property {string} type The event type.\n * @property {boolean} paused Indicates whether the ticker is currently paused.\n * @property {number} delta The time elapsed in ms since the last tick.\n * @property {number} time The total time in ms since Ticker was initialized.\n * @property {number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,\n * you could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.\n * @since 0.6.0\n */\n\nexport default Ticker;\n\n// the default Ticker instance\nconst _instance = new Ticker(\"createjs.global\");","map":{"version":3,"names":["EventDispatcher","Event","Ticker","RAF_SYNCHED","RAF","TIMEOUT","constructor","name","timingMode","maxDelta","paused","_inited","_startTime","_pausedTime","_ticks","_pausedTicks","_interval","_lastTime","_times","_tickTimes","_timerId","_raf","interval","_setupTick","framerate","init","_getTime","push","reset","f","window","cancelAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","oCancelAnimationFrame","msCancelAnimationFrame","clearTimeout","removeAllEventListeners","addEventListener","type","listener","useCapture","getMeasuredTickTime","ticks","times","length","Math","min","reduce","a","b","getMeasuredFPS","getTime","runTime","getEventTime","getTicks","pauseable","_handleSynch","_tick","_handleRAF","_handleTimeout","mode","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","bind","setTimeout","time","elapsedTime","hasEventListener","event","delta","dispatchEvent","unshift","pop","now","performance","call","Date","on","scope","once","data","_instance","removeEventListener","off","eventObj","bubbles","cancelable","willTrigger","toString"],"sources":["/Users/robert_castro/their-3d-library-robertc-team/node_modules/@createjs/core/src/utils/Ticker.js"],"sourcesContent":["/**\n * @license Ticker\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport EventDispatcher from \"../events/EventDispatcher\";\nimport Event from \"../events/Event\";\n\n/**\n * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick\n * event to be notified when a set time interval has elapsed.\n *\n * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval\n * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and\n * can not be instantiated.\n *\n * @todo Pass timingMode, maxDelta, paused values as instantiation arguments?\n *\n * @memberof core\n * @example\n * Ticker.addEventListener(\"tick\", event => {\n *   // Actions carried out each tick (aka frame)\n *   if (!event.paused) {\n *     // Actions carried out when the Ticker is not paused.\n *   }\n * });\n * @example\n * // Ticker export explanation\n * import Ticker, { Ticker as TickerClass, getTicker } from \"@createjs/core\";\n * Ticker.name, Ticker.RAF // -> createjs.global, undefined\n * TickerClass.RAF // -> raf\n * Ticker === getTicker(\"createjs.global\") // -> true\n *\n * @extends core.EventDispatcher\n * @param {string} name The name assigned to this instance.\n */\nclass Ticker extends EventDispatcher {\n\n\t/**\n\t * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It\n\t * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and\n\t * dispatches the tick when the time is within a certain threshold.\n\t *\n\t * This mode has a higher variance for time between frames than {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}},\n\t * but does not require that content be time based as with {{#crossLink \"Ticker/RAF:property\"}}{{/crossLink}} while\n\t * gaining the benefits of that API (screen synch, background throttling).\n\t *\n\t * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so\n\t * framerates of 10, 12, 15, 20, and 30 work well.\n\t *\n\t * Falls back to {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}} if the requestAnimationFrame API is not\n\t * supported.\n\t *\n\t * @static\n\t * @type {string}\n\t * @default \"synched\"\n\t * @readonly\n\t */\n\tstatic get RAF_SYNCHED () { return \"synched\"; }\n\n\t/**\n\t * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.\n\t * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.\n\t * You can leverage {@link core.Ticker#getTime} and the {@link core.Ticker#event:tick}\n\t * event object's \"delta\" properties to make this easier.\n\t *\n\t * Falls back on {@link core.Ticker.TIMEOUT} if the requestAnimationFrame API is not supported.\n\t *\n\t * @static\n\t * @type {string}\n\t * @default \"raf\"\n\t * @readonly\n\t */\n\tstatic get RAF () { return \"raf\"; }\n\n\t/**\n\t * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not\n\t * provide the benefits of requestAnimationFrame (screen synch, background throttling).\n\t *\n\t * @static\n\t * @type {string}\n\t * @default \"timeout\"\n\t * @readonly\n\t */\n\tstatic get TIMEOUT () { return \"timeout\"; }\n\n\tconstructor (name) {\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of this instance.\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use.\n\t\t *\n\t\t * @see {@link core.Ticker.TIMEOUT}\n\t\t * @see {@link core.Ticker.RAF}\n\t\t * @see {@link core.Ticker.RAF_SYNCHED}\n\t\t *\n\t\t * @type {string}\n\t\t * @default Ticker.TIMEOUT\n\t\t */\n\t\tthis.timingMode = Ticker.TIMEOUT;\n\n\t\t/**\n\t\t * Specifies a maximum value for the delta property in the tick event object. This is useful when building time\n\t\t * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,\n\t\t * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value\n\t\t * (ex. maxDelta=50 when running at 40fps).\n\t\t *\n\t\t * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta\n\t\t * when using both delta and other values.\n\t\t *\n\t\t * If 0, there is no maximum.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.maxDelta = 0;\n\n\t\t/**\n\t\t * When the ticker is paused, all listeners will still receive a tick event, but the `paused` property\n\t\t * of the event will be `true`. Also, while paused the `runTime` will not increase.\n\t\t *\n\t\t * @example\n\t\t * Ticker.addEventListener(\"tick\", event => console.log(event.paused, Ticker.getTime(false), Ticker.getTime(true)));\n\t\t * Ticker.paused = true;\n\t\t *\n\t\t * @see {@link core.Ticker#event:tick}\n\t\t * @see {@link core.Ticker#getTime}\n\t\t * @see {@link core.Ticker#getEventTime}\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.paused = false;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis._inited = false;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._startTime = 0;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._pausedTime = 0;\n\n\t\t/**\n\t\t * The number of ticks that have passed.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._ticks = 0;\n\n\t\t/**\n\t\t * The number of ticks that have passed while Ticker has been paused.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default\n\t\t */\n\t\tthis._pausedTicks = 0;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default\n\t\t */\n\t\tthis._interval = 50;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default\n\t\t */\n\t\tthis._lastTime = 0;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {Array}\n\t\t * @default null\n\t\t */\n\t\tthis._times = null;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {Array}\n\t\t * @default null\n\t\t */\n\t\tthis._tickTimes = null;\n\n\t\t/**\n\t\t * Stores the timeout or requestAnimationFrame id.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis._timerId = null;\n\n\t\t/**\n\t\t * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode\n\t\t * if that property changed and a tick hasn't fired.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis._raf = true;\n\t}\n\n\t/**\n\t * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).\n\t * Note that actual time between ticks may be more than specified depending on CPU load.\n\t * This property is ignored if the ticker is using the `RAF` timing mode.\n\t *\n\t * @type {number}\n\t */\n\tget interval () { return this._interval; }\n\tset interval (interval) {\n\t\tthis._interval = interval;\n\t\tif (!this._inited) { return; }\n\t\tthis._setupTick();\n\t}\n\n\t/**\n\t * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where\n\t * `framerate == 1000/interval`.\n\t *\n\t * @type {number}\n\t */\n\tget framerate () { return 1000 / this._interval; }\n\tset framerate (framerate) { this.interval = 1000 / framerate; }\n\n\t/**\n\t * Starts the tick. This is called automatically when the first listener is added.\n\t */\n\tinit () {\n\t\tif (this._inited) { return; }\n\t\tthis._inited = true;\n\t\tthis._times = [];\n\t\tthis._tickTimes = [];\n\t\tthis._startTime = this._getTime();\n\t\tthis._times.push(this._lastTime = 0);\n\t\tthis._setupTick();\n\t}\n\n\t/**\n\t * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.\n\t */\n\treset () {\n\t\tif (this._raf) {\n\t\t\tlet f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;\n\t\t\tf && f(this._timerId);\n\t\t} else {\n\t\t\tclearTimeout(this._timerId);\n\t\t}\n\t\tthis.removeAllEventListeners(\"tick\");\n\t\tthis._timerId = this._times = this._tickTimes = null;\n\t\tthis._startTime = this._lastTime = this._ticks = 0;\n\t\tthis._inited = false;\n\t}\n\n\t/**\n\t * Init the Ticker instance if it hasn't been already.\n\t */\n\taddEventListener (type, listener, useCapture) {\n\t\t!this._inited && this.init();\n\t\treturn super.addEventListener(type, listener, useCapture);\n\t}\n\n\t/**\n\t * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS\n\t * because it only measures the time spent within the tick execution stack.\n\t *\n\t * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between\n\t * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that\n\t * there may be up to 35ms of \"idle\" time between the end of one tick and the start of the next.\n\t *\n\t * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of\n\t * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something\n\t * other than the tick is using ~80ms (another script, DOM rendering, etc).\n\t *\n\t * @param {number} [ticks=null] The number of previous ticks over which to measure the average time spent in a tick.\n\t * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.\n\t * @return {number} The average time spent in a tick in milliseconds.\n\t */\n\tgetMeasuredTickTime (ticks = null) {\n\t\tconst times = this._tickTimes;\n\t\tif (!times || times.length < 1) { return -1; }\n\t\t// by default, calculate average for the past ~1 second:\n\t\tticks = Math.min(times.length, ticks || (this.framerate | 0));\n\t\treturn times.reduce((a, b) => a + b, 0) / ticks;\n\t}\n\n\t/**\n\t * Returns the actual frames / ticks per second.\n\t *\n\t * @param {number} [ticks=null] The number of previous ticks over which to measure the actual frames / ticks per second.\n\t * Defaults to the number of ticks per second.\n\t * @return {number} The actual frames / ticks per second. Depending on performance, this may differ\n\t * from the target frames per second.\n\t */\n\tgetMeasuredFPS (ticks = null) {\n\t\tconst times = this._times;\n\t\tif (!times || times.length < 2) { return -1; }\n\t\t// by default, calculate fps for the past ~1 second:\n\t\tticks = Math.min(times.length - 1, ticks || (this.framerate | 0));\n\t\treturn 1000 / ((times[0] - times[ticks]) / ticks);\n\t}\n\n\t/**\n\t * Returns the number of milliseconds that have elapsed since Ticker was initialized via {@link core.Ticker#init}.\n\t * Returns -1 if Ticker has not been initialized. For example, you could use\n\t * this in a time synchronized animation to determine the exact amount of time that has elapsed.\n\t *\n\t * @param {boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.\n\t * If false, the value returned will be total time elapsed since the first tick event listener was added.\n\t * @return {number} Number of milliseconds that have elapsed since Ticker was initialized or -1.\n\t */\n\tgetTime (runTime = false) {\n\t\treturn this._startTime ? this._getTime() - (runTime ? this._pausedTime : 0) : -1;\n\t}\n\n\t/**\n\t * Similar to {@link core.Ticker#getTime}, but returns the time on the most recent {@link core.Ticker#event:tick}\n\t * event object.\n\t *\n\t * @param {boolean} [runTime=false] If true, the runTime property will be returned instead of time.\n\t * @returns {number} The time or runTime property from the most recent tick event or -1.\n\t */\n\tgetEventTime (runTime = false) {\n\t\treturn this._startTime ? (this._lastTime || this._startTime) - (runTime ? this._pausedTime : 0) : -1;\n\t}\n\n\t/**\n\t * Returns the number of ticks that have been broadcast by Ticker.\n\t *\n\t * @param {boolean} [pauseable=false] Indicates whether to include ticks that would have been broadcast\n\t * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.\n\t * If false, tick events that would have been broadcast while Ticker was paused will be included in the return\n\t * value.\n\t * @return {number} of ticks that have been broadcast.\n\t */\n\tgetTicks (pauseable = false) {\n\t\treturn this._ticks - (pauseable ? this._pausedTicks : 0);\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_handleSynch () {\n\t\tthis._timerId = null;\n\t\tthis._setupTick();\n\n\t\t// run if enough time has elapsed, with a little bit of flexibility to be early:\n\t\tif (this._getTime() - this._lastTime >= (this._interval - 1) * 0.97) {\n\t\t\tthis._tick();\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_handleRAF () {\n\t\tthis._timerId = null;\n\t\tthis._setupTick();\n\t\tthis._tick();\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_handleTimeout () {\n\t\tthis._timerId = null;\n\t\tthis._setupTick();\n\t\tthis._tick();\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_setupTick () {\n\t\tif (this._timerId != null) { return; } // avoid duplicates\n\t\tconst mode = this.timingMode || (this._raf && Ticker.RAF);\n\t\tif (mode === Ticker.RAF_SYNCHED || mode === Ticker.RAF) {\n\t\t\tconst f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;\n\t\t\tif (f) {\n\t\t\t\tthis._timerId = f(mode === Ticker.RAF ? this._handleRAF.bind(this) : this._handleSynch.bind(this));\n\t\t\t\tthis._raf = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis._raf = false;\n\t\tthis._timerId = setTimeout(this._handleTimeout.bind(this), this._interval);\n\t}\n\n\t/**\n\t * @private\n\t * @emits core.Ticker#event:tick\n\t */\n\t_tick () {\n\t\tconst paused = this.paused, time = this._getTime(), elapsedTime = time - this._lastTime;\n\t\tthis._lastTime = time;\n\t\tthis._ticks++;\n\n\t\tif (paused) {\n\t\t\tthis._pausedTicks++;\n\t\t\tthis._pausedTime += elapsedTime;\n\t\t}\n\n\t\tif (this.hasEventListener(\"tick\")) {\n\t\t\tconst event = new Event(\"tick\");\n\t\t\tconst maxDelta = this.maxDelta;\n\t\t\tevent.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;\n\t\t\tevent.paused = paused;\n\t\t\tevent.time = time;\n\t\t\tevent.runTime = time - this._pausedTime;\n\t\t\tthis.dispatchEvent(event);\n\t\t}\n\n\t\tthis._tickTimes.unshift(this._getTime() - time);\n\t\twhile (this._tickTimes.length > 100) { this._tickTimes.pop(); }\n\n\t\tthis._times.unshift(time);\n\t\twhile (this._times.length > 100) { this._times.pop(); }\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_getTime () {\n\t\tconst now = window.performance && window.performance.now;\n\t\treturn ((now && now.call(performance)) || (new Date().getTime())) - this._startTime;\n\t}\n\n\tstatic on (type, listener, scope, once, data, useCapture) { return _instance.on(type, listener, scope, once, data, useCapture); }\n\tstatic removeEventListener (type, listener, useCapture) { _instance.removeEventListener(type, listener, useCapture); }\n\tstatic off (type, listener, useCapture) { _instance.off(type, listener, useCapture); }\n\tstatic removeAllEventListeners (type) { _instance.removeAllEventListeners(type); }\n\tstatic dispatchEvent (eventObj, bubbles, cancelable) { return _instance.dispatchEvent(eventObj, bubbles, cancelable); }\n\tstatic hasEventListener (type) { return _instance.hasEventListener(type); }\n\tstatic willTrigger (type) { return _instance.willTrigger(type); }\n\tstatic toString () { return _instance.toString(); }\n\tstatic init () { _instance.init(); }\n\tstatic reset () { _instance.reset(); }\n\tstatic addEventListener (type, listener, useCapture) { _instance.addEventListener(type, listener, useCapture); }\n\tstatic getMeasuredTickTime (ticks) { return _instance.getMeasuredTickTime(ticks); }\n\tstatic getMeasuredFPS (ticks) { return _instance.getMeasuredFPS(ticks); }\n\tstatic getTime (runTime) { return _instance.getTime(runTime); }\n\tstatic getEventTime (runTime) { return _instance.getEventTime(runTime); }\n\tstatic getTicks (pauseable) { return _instance.getTicks(pauseable); }\n\n\tstatic get interval () { return _instance.interval; }\n\tstatic set interval (interval) { _instance.interval = interval; }\n\tstatic get framerate () { return _instance.framerate; }\n\tstatic set framerate (framerate) { _instance.framerate = framerate; }\n\tstatic get name () { return _instance.name; }\n\tstatic set name (name) { _instance.name = name; }\n\tstatic get timingMode () { return _instance.timingMode; }\n\tstatic set timingMode (timingMode) { _instance.timingMode = timingMode; }\n\tstatic get maxDelta () { return _instance.maxDelta; }\n\tstatic set maxDelta (maxDelta) { _instance.maxDelta = maxDelta; }\n\tstatic get paused () { return _instance.paused; }\n\tstatic set paused (paused) { _instance.paused = paused; }\n\n}\n\n/**\n * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused.\n *\n * @example\n * Ticker.addEventListener(\"tick\", event => console.log(\"Paused:\", event.paused, event.delta));\n *\n * @event core.Ticker#tick\n * @type {Object}\n * @property {Object} target The object that dispatched the event.\n * @property {string} type The event type.\n * @property {boolean} paused Indicates whether the ticker is currently paused.\n * @property {number} delta The time elapsed in ms since the last tick.\n * @property {number} time The total time in ms since Ticker was initialized.\n * @property {number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,\n * you could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.\n * @since 0.6.0\n */\n\nexport default Ticker;\n\n// the default Ticker instance\nconst _instance = new Ticker(\"createjs.global\");\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,eAAe,MAAM,2BAA2B;AACvD,OAAOC,KAAK,MAAM,iBAAiB;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,MAAM,SAASF,eAAe,CAAC;EAEpC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,WAAWG,WAAW,GAAI;IAAE,OAAO,SAAS;EAAE;;EAE9C;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,WAAWC,GAAG,GAAI;IAAE,OAAO,KAAK;EAAE;;EAElC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,WAAWC,OAAO,GAAI;IAAE,OAAO,SAAS;EAAE;EAE1CC,WAAW,CAAEC,IAAI,EAAE;IAClB,KAAK,EAAE;;IAEP;AACF;AACA;AACA;IACE,IAAI,CAACA,IAAI,GAAGA,IAAI;;IAEhB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,UAAU,GAAGN,MAAM,CAACG,OAAO;;IAEhC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACI,QAAQ,GAAG,CAAC;;IAEjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,MAAM,GAAG,KAAK;;IAEnB;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,OAAO,GAAG,KAAK;;IAEpB;AACF;AACA;AACA;AACA;IACE,IA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}