{"ast":null,"code":"/**\n * @license EventDispatcher\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport Event from \"./Event\";\n\n/**\n * EventDispatcher provides methods for managing queues of event listeners and dispatching events.\n *\n * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the\n * EventDispatcher {@link core.EventDispatcher.initialize} method.\n *\n * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the\n * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports\n * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.\n *\n * EventDispatcher also exposes a {@link core.EventDispatcher#on} method, which makes it easier\n * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The\n * {@link core.EventDispatcher#off} method is merely an alias to {@link core.EventDispatcher#removeEventListener}.\n *\n * Another addition to the DOM Level 2 model is the {@link core.EventDispatcher#removeAllEventListeners}\n * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also\n * includes a {@link core.Event#remove} method which removes the active listener.\n *\n * @memberof core\n * @example\n * // add EventDispatcher capabilities to the \"MyClass\" class.\n * EventDispatcher.initialize(MyClass.prototype);\n *\n * // Add an event.\n * instance.addEventListener(\"eventName\", event => console.log(event.target + \" was clicked.\"));\n *\n * // scope (\"this\") can be be a challenge with events.\n * // using the {@link core.EventDispatcher#on} method to subscribe to events simplifies this.\n * instance.addEventListener(\"click\", event => console.log(instance === this)); // false, scope is ambiguous.\n * instance.on(\"click\", event => console.log(instance === this)); // true, `on` uses dispatcher scope by default.\n */\nclass EventDispatcher {\n  /**\n   * Static initializer to mix EventDispatcher methods into a target object or prototype.\n   *\n   * @static\n   * @example\n   * EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class\n   * EventDispatcher.initialize(myInstance); // add to a specific instance\n   *\n   * @param {Object} target The target object to inject EventDispatcher methods into.\n   */\n  static initialize(target) {\n    const p = EventDispatcher.prototype;\n    target.addEventListener = p.addEventListener;\n    target.on = p.on;\n    target.removeEventListener = target.off = p.removeEventListener;\n    target.removeAllEventListeners = p.removeAllEventListeners;\n    target.hasEventListener = p.hasEventListener;\n    target.dispatchEvent = p.dispatchEvent;\n    target._dispatchEvent = p._dispatchEvent;\n    target.willTrigger = p.willTrigger;\n  }\n  constructor() {\n    /**\n     * @private\n     * @default null\n     * @type Object\n     */\n    this._listeners = null;\n\n    /**\n     * @private\n     * @default null\n     * @type Object\n     */\n    this._captureListeners = null;\n  }\n\n  /**\n   * Adds the specified event listener. Note that adding multiple listeners to the same function will result in\n   * multiple callbacks getting fired.\n   *\n   * @example\n   * displayObject.addEventListener(\"click\", event => console.log('clicked', event));\n   *\n   * @param {string} type The string type of the event.\n   * @param {Function|Object} listener An object with a handleEvent method, or a function that will be called when the event is dispatched.\n   * @param {boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n   * @return {Function|Object} Returns the listener for chaining or assignment.\n   */\n  addEventListener(type, listener) {\n    let useCapture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let listeners;\n    if (useCapture) {\n      listeners = this._captureListeners = this._captureListeners || {};\n    } else {\n      listeners = this._listeners = this._listeners || {};\n    }\n    let arr = listeners[type];\n    if (arr) {\n      this.removeEventListener(type, listener, useCapture);\n      arr = listeners[type]; // remove may have deleted the array\n    }\n\n    if (arr) {\n      arr.push(listener);\n    } else {\n      listeners[type] = [listener];\n    }\n    return listener;\n  }\n\n  /**\n   * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener\n   * only run once, associate arbitrary data with the listener, and remove the listener.\n   *\n   * This method works by creating an anonymous wrapper function and subscribing it with `addEventListener`.\n   * The wrapper function is returned for use with `removeEventListener` (or `off`).\n   *\n   * To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use\n   * {@link core.Event#remove}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls\n   * to `on` with the same params will create multiple listeners.\n   *\n   * @example\n   * const listener = myBtn.on(\"click\", handleClick, null, false, { count: 3 });\n   * function handleClick (evt, data) {\n   *   data.count -= 1;\n   *   console.log(this == myBtn); // true - scope defaults to the dispatcher\n   *   if (data.count == 0) {\n   *     alert(\"clicked 3 times!\");\n   *     myBtn.off(\"click\", listener);\n   *     // alternately: evt.remove();\n   *   }\n   * }\n   *\n   * @param {string} type The string type of the event.\n   * @param {Function|Object} listener An object with a handleEvent method, or a function that will be called when the event is dispatched.\n   * @param {Object} [scope=null] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).\n   * @param {boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.\n   * @param {*} [data={}] Arbitrary data that will be included as the second parameter when the listener is called.\n   * @param {boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n   * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.\n   */\n  on(type, listener) {\n    let scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let data = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    let useCapture = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    if (listener.handleEvent) {\n      scope = scope || listener;\n      listener = listener.handleEvent;\n    }\n    scope = scope || this;\n    return this.addEventListener(type, evt => {\n      listener.call(scope, evt, data);\n      once && evt.remove();\n    }, useCapture);\n  }\n\n  /**\n   * Removes the specified event listener.\n   *\n   * You must pass the exact function reference used when the event was added. If a proxy\n   * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or\n   * closure will not work.\n   *\n   * @example\n   * displayObject.removeEventListener(\"click\", handleClick);\n   *\n   * @param {string} type The string type of the event.\n   * @param {Function|Object} listener The listener function or object.\n   * @param {boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n   */\n  removeEventListener(type, listener) {\n    let useCapture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const listeners = useCapture ? this._captureListeners : this._listeners;\n    if (!listeners) {\n      return;\n    }\n    const arr = listeners[type];\n    if (!arr) {\n      return;\n    }\n    const l = arr.length;\n    for (let i = 0; i < l; i++) {\n      if (arr[i] === listener) {\n        if (l === 1) {\n          delete listeners[type];\n        } // allows for faster checks.\n        else {\n          arr.splice(i, 1);\n        }\n        break;\n      }\n    }\n  }\n\n  /**\n   * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the\n   * `on` method.\n   *\n   * To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See\n   * {@link core.EventDispatcher#on} for an example.\n   *\n   * @param {string} type The string type of the event.\n   * @param {Function|Object} listener The listener function or object.\n   * @param {boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n   */\n  off(type, listener) {\n    let useCapture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this.removeEventListener(type, listener, useCapture);\n  }\n\n  /**\n   * Removes all listeners for the specified type, or all listeners of all types.\n   *\n   * @example\n   * // remove all listeners\n   * displayObject.removeAllEventListeners();\n   *\n   * // remove all click listeners\n   * displayObject.removeAllEventListeners(\"click\");\n   *\n   * @param {string} [type=null] The string type of the event. If omitted, all listeners for all types will be removed.\n   */\n  removeAllEventListeners() {\n    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (type) {\n      if (this._listeners) {\n        delete this._listeners[type];\n      }\n      if (this._captureListeners) {\n        delete this._captureListeners[type];\n      }\n    } else {\n      this._listeners = this._captureListeners = null;\n    }\n  }\n\n  /**\n   * Dispatches the specified event to all listeners.\n   *\n   * @example\n   * // use a string event\n   * this.dispatchEvent(\"complete\")\n   *\n   * // use an Event instance\n   * const event = new createjs.Event(\"progress\");\n   * this.dispatchEvent(event);\n   *\n   * @param {Object|Event|string} eventObj An object with a \"type\" property, or a string type.\n   * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,\n   * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can\n   * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.\n   * @param {boolean} [bubbles=false] Specifies the `bubbles` value when a string was passed to eventObj.\n   * @param {boolean} [cancelable=false] Specifies the `cancelable` value when a string was passed to eventObj.\n   * @return {boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.\n   */\n  dispatchEvent(eventObj) {\n    let bubbles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let cancelable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (typeof eventObj === \"string\") {\n      // skip everything if there's no listeners and it doesn't bubble:\n      const listeners = this._listeners;\n      if (!bubbles && (!listeners || !listeners[eventObj])) {\n        return true;\n      }\n      eventObj = new Event(eventObj, bubbles, cancelable);\n    } else if (eventObj.target && eventObj.clone) {\n      // redispatching an active event object, so clone it:\n      eventObj = eventObj.clone();\n    }\n\n    // TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent\n    try {\n      eventObj.target = this;\n    } catch (e) {} // try/catch allows redispatching of native events\n\n    if (!eventObj.bubbles || !this.parent) {\n      this._dispatchEvent(eventObj, 2);\n    } else {\n      let top = this;\n      const list = [top];\n      while (top.parent) {\n        list.push(top = top.parent);\n      }\n      const l = list.length;\n      let i;\n\n      // capture & atTarget\n      for (i = l - 1; i >= 0 && !eventObj.propagationStopped; i--) {\n        list[i]._dispatchEvent(eventObj, 1 + (i == 0));\n      }\n      // bubbling\n      for (i = 1; i < l && !eventObj.propagationStopped; i++) {\n        list[i]._dispatchEvent(eventObj, 3);\n      }\n    }\n    return !eventObj.defaultPrevented;\n  }\n\n  /**\n   * Indicates whether there is at least one listener for the specified event type.\n   *\n   * @param {string} type The string type of the event.\n   * @return {boolean} Returns true if there is at least one listener for the specified event.\n   */\n  hasEventListener(type) {\n    const listeners = this._listeners,\n      captureListeners = this._captureListeners;\n    return !!(listeners && listeners[type] || captureListeners && captureListeners[type]);\n  }\n\n  /**\n   * Indicates whether there is at least one listener for the specified event type on this object or any of its\n   * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the\n   * specified type is dispatched from this object, it will trigger at least one listener.\n   *\n   * This is similar to {@link core.EventDispatcher#hasEventListener}, but it searches the entire\n   * event flow for a listener, not just this object.\n   *\n   * @param {string} type The string type of the event.\n   * @return {boolean} Returns `true` if there is at least one listener for the specified event.\n   */\n  willTrigger(type) {\n    let o = this;\n    while (o) {\n      if (o.hasEventListener(type)) {\n        return true;\n      }\n      o = o.parent;\n    }\n    return false;\n  }\n\n  /**\n   * @return {String} a string representation of the instance.\n   */\n  toString() {\n    return `[${this.constructor.name + this.name ? ` ${this.name}` : \"\"}]`;\n  }\n\n  /**\n   * @private\n   * @param {Object|Event|string} eventObj\n   * @param {Object} eventPhase\n   */\n  _dispatchEvent(eventObj, eventPhase) {\n    const listeners = eventPhase === 1 ? this._captureListeners : this._listeners;\n    if (eventObj && listeners) {\n      let arr = listeners[eventObj.type];\n      let l;\n      if (!arr || (l = arr.length) === 0) {\n        return;\n      }\n      try {\n        eventObj.currentTarget = this;\n      } catch (e) {}\n      try {\n        eventObj.eventPhase = eventPhase;\n      } catch (e) {}\n      eventObj.removed = false;\n      arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch\n      for (let i = 0; i < l && !eventObj.immediatePropagationStopped; i++) {\n        let o = arr[i];\n        if (o.handleEvent) {\n          o.handleEvent(eventObj);\n        } else {\n          o(eventObj);\n        }\n        if (eventObj.removed) {\n          this.off(eventObj.type, o, eventPhase === 1);\n          eventObj.removed = false;\n        }\n      }\n    }\n  }\n}\nexport default EventDispatcher;","map":{"version":3,"names":["Event","EventDispatcher","initialize","target","p","prototype","addEventListener","on","removeEventListener","off","removeAllEventListeners","hasEventListener","dispatchEvent","_dispatchEvent","willTrigger","constructor","_listeners","_captureListeners","type","listener","useCapture","listeners","arr","push","scope","once","data","handleEvent","evt","call","remove","l","length","i","splice","eventObj","bubbles","cancelable","clone","e","parent","top","list","propagationStopped","defaultPrevented","captureListeners","o","toString","name","eventPhase","currentTarget","removed","slice","immediatePropagationStopped"],"sources":["/Users/robert_castro/their-3d-library-robertc-team/node_modules/@createjs/core/src/events/EventDispatcher.js"],"sourcesContent":["/**\n * @license EventDispatcher\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport Event from \"./Event\";\n\n/**\n * EventDispatcher provides methods for managing queues of event listeners and dispatching events.\n *\n * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the\n * EventDispatcher {@link core.EventDispatcher.initialize} method.\n *\n * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the\n * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports\n * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.\n *\n * EventDispatcher also exposes a {@link core.EventDispatcher#on} method, which makes it easier\n * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The\n * {@link core.EventDispatcher#off} method is merely an alias to {@link core.EventDispatcher#removeEventListener}.\n *\n * Another addition to the DOM Level 2 model is the {@link core.EventDispatcher#removeAllEventListeners}\n * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also\n * includes a {@link core.Event#remove} method which removes the active listener.\n *\n * @memberof core\n * @example\n * // add EventDispatcher capabilities to the \"MyClass\" class.\n * EventDispatcher.initialize(MyClass.prototype);\n *\n * // Add an event.\n * instance.addEventListener(\"eventName\", event => console.log(event.target + \" was clicked.\"));\n *\n * // scope (\"this\") can be be a challenge with events.\n * // using the {@link core.EventDispatcher#on} method to subscribe to events simplifies this.\n * instance.addEventListener(\"click\", event => console.log(instance === this)); // false, scope is ambiguous.\n * instance.on(\"click\", event => console.log(instance === this)); // true, `on` uses dispatcher scope by default.\n */\nclass EventDispatcher {\n\n\t/**\n\t * Static initializer to mix EventDispatcher methods into a target object or prototype.\n\t *\n\t * @static\n\t * @example\n\t * EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class\n\t * EventDispatcher.initialize(myInstance); // add to a specific instance\n\t *\n\t * @param {Object} target The target object to inject EventDispatcher methods into.\n\t */\n\tstatic initialize (target) {\n\t\tconst p = EventDispatcher.prototype;\n\t\ttarget.addEventListener = p.addEventListener;\n\t\ttarget.on = p.on;\n\t\ttarget.removeEventListener = target.off = p.removeEventListener;\n\t\ttarget.removeAllEventListeners = p.removeAllEventListeners;\n\t\ttarget.hasEventListener = p.hasEventListener;\n\t\ttarget.dispatchEvent = p.dispatchEvent;\n\t\ttarget._dispatchEvent = p._dispatchEvent;\n\t\ttarget.willTrigger = p.willTrigger;\n\t}\n\n\tconstructor () {\n\t\t/**\n\t\t * @private\n\t\t * @default null\n\t\t * @type Object\n\t\t */\n\t\tthis._listeners = null;\n\n\t\t/**\n\t\t * @private\n\t\t * @default null\n\t\t * @type Object\n\t\t */\n\t\tthis._captureListeners = null;\n\t}\n\n\t/**\n\t * Adds the specified event listener. Note that adding multiple listeners to the same function will result in\n\t * multiple callbacks getting fired.\n\t *\n\t * @example\n\t * displayObject.addEventListener(\"click\", event => console.log('clicked', event));\n\t *\n\t * @param {string} type The string type of the event.\n\t * @param {Function|Object} listener An object with a handleEvent method, or a function that will be called when the event is dispatched.\n\t * @param {boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t * @return {Function|Object} Returns the listener for chaining or assignment.\n\t */\n\taddEventListener (type, listener, useCapture = false) {\n\t\tlet listeners;\n\t\tif (useCapture) {\n\t\t\tlisteners = this._captureListeners = this._captureListeners || {};\n\t\t} else {\n\t\t\tlisteners = this._listeners = this._listeners || {};\n\t\t}\n\t\tlet arr = listeners[type];\n\t\tif (arr) {\n\t\t\tthis.removeEventListener(type, listener, useCapture);\n\t\t\tarr = listeners[type]; // remove may have deleted the array\n\t\t}\n\t\tif (arr) { arr.push(listener);  }\n\t\telse { listeners[type] = [listener]; }\n\t\treturn listener;\n\t}\n\n\t/**\n\t * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener\n\t * only run once, associate arbitrary data with the listener, and remove the listener.\n\t *\n\t * This method works by creating an anonymous wrapper function and subscribing it with `addEventListener`.\n\t * The wrapper function is returned for use with `removeEventListener` (or `off`).\n\t *\n\t * To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use\n\t * {@link core.Event#remove}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls\n\t * to `on` with the same params will create multiple listeners.\n\t *\n\t * @example\n\t * const listener = myBtn.on(\"click\", handleClick, null, false, { count: 3 });\n\t * function handleClick (evt, data) {\n\t *   data.count -= 1;\n\t *   console.log(this == myBtn); // true - scope defaults to the dispatcher\n\t *   if (data.count == 0) {\n\t *     alert(\"clicked 3 times!\");\n\t *     myBtn.off(\"click\", listener);\n\t *     // alternately: evt.remove();\n\t *   }\n\t * }\n\t *\n\t * @param {string} type The string type of the event.\n\t * @param {Function|Object} listener An object with a handleEvent method, or a function that will be called when the event is dispatched.\n\t * @param {Object} [scope=null] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).\n\t * @param {boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.\n\t * @param {*} [data={}] Arbitrary data that will be included as the second parameter when the listener is called.\n\t * @param {boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.\n\t */\n\ton (type, listener, scope = null, once = false, data = {}, useCapture = false) {\n\t\tif (listener.handleEvent) {\n\t\t\tscope = scope || listener;\n\t\t\tlistener = listener.handleEvent;\n\t\t}\n\t\tscope = scope || this;\n\t\treturn this.addEventListener(type, evt => {\n\t\t\tlistener.call(scope, evt, data);\n\t\t\tonce && evt.remove();\n\t\t}, useCapture);\n\t}\n\n\t/**\n\t * Removes the specified event listener.\n\t *\n\t * You must pass the exact function reference used when the event was added. If a proxy\n\t * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or\n\t * closure will not work.\n\t *\n\t * @example\n\t * displayObject.removeEventListener(\"click\", handleClick);\n\t *\n\t * @param {string} type The string type of the event.\n\t * @param {Function|Object} listener The listener function or object.\n\t * @param {boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t */\n\tremoveEventListener (type, listener, useCapture = false) {\n\t\tconst listeners = useCapture ? this._captureListeners : this._listeners;\n\t\tif (!listeners) { return; }\n\t\tconst arr = listeners[type];\n\t\tif (!arr) { return; }\n\t\tconst l = arr.length;\n\t\tfor (let i = 0; i < l; i++) {\n\t\t\tif (arr[i] === listener) {\n\t\t\t\tif (l === 1) { delete(listeners[type]); } // allows for faster checks.\n\t\t\t\telse { arr.splice(i, 1); }\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the\n\t * `on` method.\n\t *\n\t * To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See\n\t * {@link core.EventDispatcher#on} for an example.\n\t *\n\t * @param {string} type The string type of the event.\n\t * @param {Function|Object} listener The listener function or object.\n\t * @param {boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t */\n\toff (type, listener, useCapture = false) {\n\t\tthis.removeEventListener(type, listener, useCapture);\n\t}\n\n\t/**\n\t * Removes all listeners for the specified type, or all listeners of all types.\n\t *\n\t * @example\n\t * // remove all listeners\n\t * displayObject.removeAllEventListeners();\n\t *\n\t * // remove all click listeners\n\t * displayObject.removeAllEventListeners(\"click\");\n\t *\n\t * @param {string} [type=null] The string type of the event. If omitted, all listeners for all types will be removed.\n\t */\n\tremoveAllEventListeners (type = null) {\n\t\tif (type) {\n\t\t\tif (this._listeners) { delete(this._listeners[type]); }\n\t\t\tif (this._captureListeners) { delete(this._captureListeners[type]); }\n\t\t} else {\n\t\t\tthis._listeners = this._captureListeners = null;\n\t\t}\n\t}\n\n\t/**\n\t * Dispatches the specified event to all listeners.\n\t *\n\t * @example\n\t * // use a string event\n\t * this.dispatchEvent(\"complete\")\n\t *\n\t * // use an Event instance\n\t * const event = new createjs.Event(\"progress\");\n\t * this.dispatchEvent(event);\n\t *\n\t * @param {Object|Event|string} eventObj An object with a \"type\" property, or a string type.\n\t * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,\n\t * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can\n\t * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.\n\t * @param {boolean} [bubbles=false] Specifies the `bubbles` value when a string was passed to eventObj.\n\t * @param {boolean} [cancelable=false] Specifies the `cancelable` value when a string was passed to eventObj.\n\t * @return {boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.\n\t */\n\tdispatchEvent (eventObj, bubbles = false, cancelable = false) {\n\t\tif (typeof eventObj === \"string\") {\n\t\t\t// skip everything if there's no listeners and it doesn't bubble:\n\t\t\tconst listeners = this._listeners;\n\t\t\tif (!bubbles && (!listeners || !listeners[eventObj])) { return true; }\n\t\t\teventObj = new Event(eventObj, bubbles, cancelable);\n\t\t} else if (eventObj.target && eventObj.clone) {\n\t\t\t// redispatching an active event object, so clone it:\n\t\t\teventObj = eventObj.clone();\n\t\t}\n\n\t\t// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent\n\t\ttry { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events\n\n\t\tif (!eventObj.bubbles || !this.parent) {\n\t\t\tthis._dispatchEvent(eventObj, 2);\n\t\t} else {\n\t\t\tlet top = this;\n\t\t\tconst list = [top];\n\t\t\twhile (top.parent) { list.push(top = top.parent); }\n\t\t\tconst l = list.length;\n\t\t\tlet i;\n\n\t\t\t// capture & atTarget\n\t\t\tfor (i = l - 1; i >= 0 && !eventObj.propagationStopped; i--) {\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 1+(i==0));\n\t\t\t}\n\t\t\t// bubbling\n\t\t\tfor (i = 1; i < l && !eventObj.propagationStopped; i++) {\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 3);\n\t\t\t}\n\t\t}\n\t\treturn !eventObj.defaultPrevented;\n\t}\n\n\t/**\n\t * Indicates whether there is at least one listener for the specified event type.\n\t *\n\t * @param {string} type The string type of the event.\n\t * @return {boolean} Returns true if there is at least one listener for the specified event.\n\t */\n\thasEventListener (type) {\n\t\tconst listeners = this._listeners, captureListeners = this._captureListeners;\n\t\treturn !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));\n\t}\n\n\t/**\n\t * Indicates whether there is at least one listener for the specified event type on this object or any of its\n\t * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the\n\t * specified type is dispatched from this object, it will trigger at least one listener.\n\t *\n\t * This is similar to {@link core.EventDispatcher#hasEventListener}, but it searches the entire\n\t * event flow for a listener, not just this object.\n\t *\n\t * @param {string} type The string type of the event.\n\t * @return {boolean} Returns `true` if there is at least one listener for the specified event.\n\t */\n\twillTrigger (type) {\n\t\tlet o = this;\n\t\twhile (o) {\n\t\t\tif (o.hasEventListener(type)) { return true; }\n\t\t\to = o.parent;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @return {String} a string representation of the instance.\n\t */\n\ttoString () {\n\t\treturn `[${this.constructor.name + this.name ? ` ${this.name}` : \"\"}]`;\n\t}\n\n\t/**\n\t * @private\n\t * @param {Object|Event|string} eventObj\n\t * @param {Object} eventPhase\n\t */\n\t_dispatchEvent (eventObj, eventPhase) {\n\t\tconst listeners = eventPhase === 1 ? this._captureListeners : this._listeners;\n\t\tif (eventObj && listeners) {\n\t\t\tlet arr = listeners[eventObj.type];\n\t\t\tlet l;\n\t\t\tif (!arr || (l = arr.length) === 0) { return; }\n\t\t\ttry { eventObj.currentTarget = this; } catch (e) {}\n\t\t\ttry { eventObj.eventPhase = eventPhase; } catch (e) {}\n\t\t\teventObj.removed = false;\n\n\t\t\tarr = arr.slice(); // to avoid issues with items being removed or added during the dispatch\n\t\t\tfor (let i = 0; i < l && !eventObj.immediatePropagationStopped; i++) {\n\t\t\t\tlet o = arr[i];\n\t\t\t\tif (o.handleEvent) { o.handleEvent(eventObj); }\n\t\t\t\telse { o(eventObj); }\n\t\t\t\tif (eventObj.removed) {\n\t\t\t\t\tthis.off(eventObj.type, o, eventPhase === 1);\n\t\t\t\t\teventObj.removed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nexport default EventDispatcher;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,KAAK,MAAM,SAAS;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,eAAe,CAAC;EAErB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,OAAOC,UAAU,CAAEC,MAAM,EAAE;IAC1B,MAAMC,CAAC,GAAGH,eAAe,CAACI,SAAS;IACnCF,MAAM,CAACG,gBAAgB,GAAGF,CAAC,CAACE,gBAAgB;IAC5CH,MAAM,CAACI,EAAE,GAAGH,CAAC,CAACG,EAAE;IAChBJ,MAAM,CAACK,mBAAmB,GAAGL,MAAM,CAACM,GAAG,GAAGL,CAAC,CAACI,mBAAmB;IAC/DL,MAAM,CAACO,uBAAuB,GAAGN,CAAC,CAACM,uBAAuB;IAC1DP,MAAM,CAACQ,gBAAgB,GAAGP,CAAC,CAACO,gBAAgB;IAC5CR,MAAM,CAACS,aAAa,GAAGR,CAAC,CAACQ,aAAa;IACtCT,MAAM,CAACU,cAAc,GAAGT,CAAC,CAACS,cAAc;IACxCV,MAAM,CAACW,WAAW,GAAGV,CAAC,CAACU,WAAW;EACnC;EAEAC,WAAW,GAAI;IACd;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,UAAU,GAAG,IAAI;;IAEtB;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,iBAAiB,GAAG,IAAI;EAC9B;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCX,gBAAgB,CAAEY,IAAI,EAAEC,QAAQ,EAAsB;IAAA,IAApBC,UAAU,uEAAG,KAAK;IACnD,IAAIC,SAAS;IACb,IAAID,UAAU,EAAE;MACfC,SAAS,GAAG,IAAI,CAACJ,i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"},"metadata":{},"sourceType":"module","externalDependencies":[]}